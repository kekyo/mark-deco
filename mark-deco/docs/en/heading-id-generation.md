## Heading ID Generation and Heading Information Extraction

The processor automatically generates unique IDs for all headings (H1-H6) in the document. These IDs can be used for anchor links and navigation. ID generation supports two modes and includes advanced processing for non-ASCII characters.

IDs are embedded in HTML and also exposed through the `headingTree` property of processing results. This information can be used for table of contents generation, document structure analysis, etc:

```typescript
const markdown = `# Introduction

This is the introduction section.

# Usage

Explains basic usage.

## Subsection

This is an H2 heading subsection.

# Conclusion

This is the conclusion section.`;

const result = await processor.process(markdown, 'id');

// Output heading information (described later)
console.log(result.headingTree);
```

Example HTML generated by the above code (hierarchical heading IDs enabled by default):

```html
<h1 id="id-1">Introduction</h1>
<p>This is the introduction section.</p>
<h1 id="id-2">Usage</h1>
<p>Explains basic usage.</p>
<h2 id="id-2-1">Subsection</h2>
<p>This is an H2 heading subsection.</p>
<h1 id="id-3">Conclusion</h1>
<p>This is the conclusion section.</p>
```

### Hierarchical Heading IDs

There's a feature to generate IDs that reflect heading hierarchy. When the `useHierarchicalHeadingId` option is `true`, hierarchical numbers based on heading levels are assigned.

This feature generates heading IDs in the following format:

| Heading Level | ID Format  | Example                            |
| ------------- | ---------- | ---------------------------------- |
| H1            | `id-N`     | `id-1`, `id-2`, `id-3`             |
| H2            | `id-N-M`   | `id-1-1`, `id-1-2`, `id-2-1`       |
| H3            | `id-N-M-L` | `id-1-1-1`, `id-1-1-2`, `id-1-2-1` |

This makes heading structure clear and useful for navigation and table of contents generation.

When `useHierarchicalHeadingId` is set to `false`, ID numbers are assigned sequentially rather than hierarchically:

```typescript
const result = await processor.process(markdown, 'id', {
  // Disable hierarchical heading IDs
  useHierarchicalHeadingId: false,
});
```

Example heading ID generation with sequential numbering:

| Heading Level | ID Format | Example                                |
| ------------- | --------- | -------------------------------------- |
| All headings  | `id-N`    | `id-1`, `id-2`, `id-3`, `id-4`, `id-5` |

Note: In sequential mode, all headings in the document are assigned numbers sequentially regardless of heading level.

### Custom ID Prefix

You can customize the prefix used for IDs. These can be used to generate unique IDs for each tag when concatenating multiple HTML:

```typescript
// Specify ID prefix as the second argument
// Generated IDs: "id-1", "id-2", "id-3", etc.
const result = await processor.process(markdown, 'id');

// Generated IDs: "section-1", "section-2", "section-3", etc.
const result = await processor.process(markdown, 'section');

// Content-based IDs (<h?> tags only, described later)
const result = await processor.process(markdown, 'id', {
  useContentStringHeaderId: true,
});

// Example of making IDs completely unique when generating multiple HTMLs:
// "id1-1", "id1-2", "id2-1", "id2-2", "id3-1" ...
const results = await Promise.all(
  markdowns.map((markdown, index) => processor.process(markdown, `id${index}`))
);
```

### Content-Based IDs

You can enable content-based IDs that generate IDs from heading text:

```typescript
// Generate human-readable IDs from heading text
const markdown = `# Hello world

## Another section

### Subsection`;

const result = await processor.process(markdown, 'id', {
  useContentStringHeaderId: true,
});
```

Result:

```html
<h1 id="hello-world">Hello World</h1>
<h2 id="hello-world-another-section">Another Section</h2>
<h3 id="hello-world-another-section-subsection">Subsection</h3>
```

When using content-based IDs, the processor employs sophisticated fallback strategies to handle various text inputs:

#### Step 1: Unicode Normalization and Accent Removal

Normalizes European language accents to ASCII equivalent characters:

- Input: "Caf√© Na√Øve"
- Output: "cafe-naive"

- Input: "R√©sum√©"
- Output: "resume"

#### Step 2: Control Character Processing

Converts escape sequences and control characters to hyphens:

- Input: "Section\n\nTitle"
- Output: "section-title"

- Input: "Hello\tWorld"
- Output: "hello-world"

#### Step 3: ASCII Character Extraction

Removes non-ASCII characters (Japanese, Chinese, emojis, etc.):

- Input: "Hello ‰∏ñÁïå World"
- Output: "hello-world"

- Input: "üéâ lucky time!"
- Output: "lucky-time"

#### Step 4: Invalid ID Fallback

When the resulting ID is too short (less than 3 characters) or empty, the processor falls back to unique IDs:

- Input: "„Åì„Çì„Å´„Å°„ÅØ" (Japanese only)
- Output: "id-1" (fallback)

- Input: "üéâ" (emoji only)
- Output: "id-2" (fallback)

- Input: "A" (too short)
- Output: "id-3" (fallback)

### ID Generation Examples

| Input Heading      | Generated ID    | Processing                   |
| :----------------- | :-------------- | :--------------------------- |
| `"Hello World"`    | `"hello-world"` | Standard processing          |
| `"Caf√© Na√Øve"`     | `"cafe-naive"`  | Unicode normalization        |
| `"Section\n\nTwo"` | `"section-two"` | Control character processing |
| `"Hello ‰∏ñÁïå"`     | `"hello"`       | Non-ASCII removal            |
| `"„Åì„Çì„Å´„Å°„ÅØ"`     | `"id-1"`        | Fallback (non-ASCII only)    |
| `"üéâ „Éë„Éº„ÉÜ„Ç£„Éº"`  | `"id-2"`        | Fallback (emoji + Japanese)  |
| `"A"`              | `"id-3"`        | Fallback (too short)         |

Note: While many sites adopt such content-based IDs, MarkDeco doesn't use them by default.
The reason is that building IDs with non-English characters makes them very difficult to recognize and manage, and search systems don't particularly value them highly nowadays.
